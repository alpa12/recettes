---
title: Ajouter une recette
image: index.jpg
order: 4
---

```{r}
#| echo: false
#| results: asis
#| message: false
#| warning: false
library(yaml)
library(jsonlite)

template <- yaml::read_yaml("../template.yaml")
schema <- template$`_schema`

token <- Sys.getenv("GITHUB_PAT")
if (identical(token, "")) stop("GITHUB_PAT est vide/non défini sur Connect.")

cat(
  "<script>",
  "window.RECIPE_SCHEMA = ", jsonlite::toJSON(schema, auto_unbox = TRUE), ";",
  "window.GITHUB_PAT = ",  jsonlite::toJSON(token, auto_unbox = TRUE), ";",
  "</script>"
)
```

::: {.panel-tabset}

## Formulaire manuel

<div id="recipe-form-container"></div>

<div id="success-message" class="alert alert-success d-none"></div>
<div id="error-message" class="alert alert-danger d-none"></div>

## Importer depuis une URL

<div class="alert alert-warning" role="alert">
  <h5>⚠️ Import automatique avec IA</h5>
  <p class="mb-0">Cette fonctionnalité utilise un LLM pour extraire automatiquement les informations de la recette depuis une URL. L'import sera validé manuellement avant publication.</p>
</div>

<form id="url-form" class="mb-4 needs-validation" novalidate>
  <div class="mb-3">
    <label for="recipe-url" class="form-label required-field">URL de la recette</label>
    <input type="url" class="form-control" id="recipe-url" placeholder="https://exemple.com/ma-recette" required>
    <div class="invalid-feedback">Veuillez entrer une URL valide.</div>
    <div class="form-text">Entrez l'URL complète d'une recette sur un site web externe.</div>
  </div>

  <div class="mb-3">
    <label for="url-submitted-by" class="form-label">Votre nom (optionnel)</label>
    <input type="text" class="form-control" id="url-submitted-by" placeholder="Votre nom">
  </div>

  <div class="d-grid gap-2">
    <button type="submit" class="btn btn-primary btn-lg">Soumettre l'URL</button>
  </div>
</form>

<div id="url-success-message" class="alert alert-success d-none" role="alert">
  <h4 class="alert-heading">✅ URL soumise avec succès!</h4>
  <p>Une Pull Request a été créée avec votre URL. L'import automatique sera effectué après validation manuelle.</p>
  <p class="mb-0">Vous pouvez la voir ici: <a id="url-pr-link" href="#" target="_blank" class="alert-link" rel="noopener noreferrer"></a></p>
</div>

<div id="url-error-message" class="alert alert-danger d-none" role="alert">
  <h4 class="alert-heading">❌ Erreur</h4>
  <p id="url-error-text"></p>
</div>

:::

<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

<style>
/* Reproduit le look des onglets de l'ancien code (s'applique aussi au panel-tabset Quarto) */
.nav-tabs {
  border-bottom: 2px solid var(--bs-primary);
}

.nav-tabs .nav-link {
  border: none;
  color: var(--bs-secondary);
  padding: 0.75rem 1.5rem;
  font-weight: 500;
}

.nav-tabs .nav-link:hover {
  border: none;
  color: var(--bs-primary);
  background-color: var(--bs-light);
}

.nav-tabs .nav-link.active {
  color: var(--bs-primary);
  background-color: transparent;
  border: none;
  border-bottom: 3px solid var(--bs-primary);
}

/* Petit détail visuel utilisé par l'ancienne version */
.required-field::after {
  content: " *";
  color: var(--bs-danger);
}
</style>

<script>
document.addEventListener("DOMContentLoaded", () => {
  renderForm(window.RECIPE_SCHEMA, "recipe-form-container", []);

  const urlForm = document.getElementById("url-form");
  if (urlForm) {
    urlForm.addEventListener("submit", handleUrlSubmit);
  }
});

// ---------------------------
//  Helpers UI (manuel)
// ---------------------------
function showSuccess(prUrl) {
  const success = document.getElementById("success-message");
  const error = document.getElementById("error-message");

  error.classList.add("d-none");
  error.innerHTML = "";

  success.classList.remove("d-none");
  success.innerHTML = `
    <div><strong>Demande d'ajout créée avec succès !</strong></div>
    <div><a href="${prUrl}" target="_blank" rel="noopener noreferrer">${prUrl}</a></div>
  `;
}

function showError(message) {
  const success = document.getElementById("success-message");
  const error = document.getElementById("error-message");

  success.classList.add("d-none");
  success.innerHTML = "";

  error.classList.remove("d-none");
  error.innerHTML = `<strong>Erreur :</strong> ${message}`;
}

function clearMessages() {
  const success = document.getElementById("success-message");
  const error = document.getElementById("error-message");
  success.classList.add("d-none");
  success.innerHTML = "";
  error.classList.add("d-none");
  error.innerHTML = "";
}

function resetForm(form) {
  form.reset();
  form.classList.remove("was-validated");

  // For safety with dynamic inputs
  form.querySelectorAll("input").forEach((inp) => {
    if (inp.type === "checkbox") inp.checked = false;
    else inp.value = "";
  });
}

function setSubmitLoading(form, isLoading, label="Soumettre la recette") {
  const btn = form.querySelector('button[type="submit"]');
  if (!btn) return;

  if (isLoading) {
    btn.disabled = true;
    btn.dataset.originalText = btn.dataset.originalText || btn.textContent;
    btn.innerHTML = `
      <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
      Création de la demande d'ajout d'une recette...
    `;
    form.setAttribute("aria-busy", "true");
  } else {
    btn.disabled = false;
    btn.innerHTML = btn.dataset.originalText || label;
    form.removeAttribute("aria-busy");
  }
}

// ---------------------------
//  Form rendering (manuel)
// ---------------------------
function renderForm(schema, containerId, path) {
  const container = document.getElementById(containerId);
  container.innerHTML = "";

  const form = document.createElement("form");
  form.classList.add("needs-validation");
  form.noValidate = true;

  form.appendChild(renderObject(schema, path));

  const btn = document.createElement("button");
  btn.type = "submit";
  btn.className = "btn btn-primary mt-3";
  btn.textContent = "Soumettre la recette";
  form.appendChild(btn);

  form.addEventListener("submit", handleSubmit);
  container.appendChild(form);
}

function renderObject(schema, path) {
  const wrapper = document.createElement("div");

  Object.entries(schema.properties).forEach(([key, prop]) => {
    const fieldPath = [...path, key];

    if (prop.type === "object") {
      wrapper.appendChild(renderSection(prop, key, fieldPath));
    } else if (prop.type === "array") {
      wrapper.appendChild(renderArray(prop, key, fieldPath));
    } else {
      wrapper.appendChild(renderPrimitive(prop, key, fieldPath, schema.required?.includes(key)));
    }
  });

  return wrapper;
}

function renderSection(schema, title, path) {
  const div = document.createElement("div");
  div.className = "card mb-3";

  const body = document.createElement("div");
  body.className = "card-body";

  const h = document.createElement("h5");
  h.className = "card-title";
  h.textContent = schema.title || title;
  body.appendChild(h);

  body.appendChild(renderObject(schema, path));
  div.appendChild(body);
  return div;
}

function renderArray(schema, key, path) {
  const div = document.createElement("div");
  div.className = "mb-3";

  const label = document.createElement("label");
  label.className = "form-label fw-bold";
  label.textContent = schema.title || key;
  div.appendChild(label);

  const list = document.createElement("div");
  div.appendChild(list);

  const addBtn = document.createElement("button");
  addBtn.type = "button";
  addBtn.className = "btn btn-outline-primary btn-sm mt-2";
  addBtn.textContent = "+ Ajouter";
  addBtn.onclick = () => {
    list.appendChild(renderArrayItem(schema.items, path));
  };

  div.appendChild(addBtn);
  return div;
}

function renderArrayItem(itemSchema, path) {
  const itemDiv = document.createElement("div");
  itemDiv.className = "border rounded p-3 mt-2";

  if (itemSchema.type === "object") {
    itemDiv.appendChild(renderObject(itemSchema, path));
  } else {
    itemDiv.appendChild(renderPrimitive(itemSchema, "", path));
  }

  const removeBtn = document.createElement("button");
  removeBtn.type = "button";
  removeBtn.className = "btn btn-sm btn-outline-danger mt-2";
  removeBtn.textContent = "Retirer";
  removeBtn.onclick = () => itemDiv.remove();

  itemDiv.appendChild(removeBtn);
  return itemDiv;
}

function renderPrimitive(schema, key, path, required=false) {
  const div = document.createElement("div");
  div.className = "mb-3";

  const label = document.createElement("label");
  label.className = "form-label";
  label.textContent = schema.title || key;
  div.appendChild(label);

  let input;

  if (schema.type === "boolean") {
    input = document.createElement("input");
    input.type = "checkbox";
    input.className = "form-check-input ms-2";
  } else {
    input = document.createElement("input");
    input.type = (schema.type === "integer" || schema.type === "number") ? "number" : "text";
    input.className = "form-control";
  }

  input.dataset.path = path.join(".");
  if (required) input.required = true;

  if (schema.description)
    input.placeholder = schema.description;

  div.appendChild(input);
  return div;
}

// ---------------------------
//  GitHub helpers
// ---------------------------
async function safeJson(resp) {
  try { return await resp.json(); } catch { return null; }
}

async function createBranchWithSuffixes({ owner, repo, headers, baseSha, baseBranchName, maxAttempts=20 }) {
  // Try base branchName first, then add -2, -3, ...
  for (let i = 1; i <= maxAttempts; i++) {
    const branchName = (i === 1) ? baseBranchName : `${baseBranchName}-${i}`;
    const resp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/git/refs`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          ref: `refs/heads/${branchName}`,
          sha: baseSha
        })
      }
    );

    const data = await safeJson(resp);

    if (resp.ok) {
      return branchName;
    }

    // 422 typically means ref exists already (or validation error)
    const msg = (data && data.message) ? data.message : "";
    const isAlreadyExists = resp.status === 422 && msg.toLowerCase().includes("reference already exists");
    if (isAlreadyExists) continue;

    throw new Error(msg || `Impossible de créer la branche (status ${resp.status}).`);
  }

  throw new Error("Impossible de créer une branche unique après plusieurs tentatives.");
}

// ---------------------------
//  Submit handler (manuel)
// ---------------------------
async function handleSubmit(e) {
  e.preventDefault();
  clearMessages();

  const form = e.target;

  if (!form.checkValidity()) {
    form.classList.add("was-validated");
    return;
  }

  setSubmitLoading(form, true);

  try {
    const data = collectData(window.RECIPE_SCHEMA, form);
    const yamlContent = jsyaml.dump(data, { indent: 2, lineWidth: -1 });

    const token = window.GITHUB_PAT;
    const owner = "alpa12";
    const repo = "recettes";
    const base = "dev";

    const headers = {
      "Authorization": "token " + token,
      "Accept": "application/vnd.github+json"
    };

    // 1️⃣ Get dev branch SHA
    const refResp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/git/ref/heads/${base}`,
      { headers }
    );
    const refData = await safeJson(refResp);
    if (!refResp.ok) throw new Error(refData?.message || "Impossible de lire la branche de base.");
    const baseSha = refData.object.sha;

    const baseBranchName = `recette/${data.nom_court}`;
    const filePath = `recettes/${data.nom_court}.yaml`;

    // 2️⃣ Create branch (with auto-suffix if it already exists)
    const branchName = await createBranchWithSuffixes({
      owner, repo, headers, baseSha, baseBranchName, maxAttempts: 20
    });

    // 3️⃣ Create file
    const fileResp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`,
      {
        method: "PUT",
        headers,
        body: JSON.stringify({
          message: `Ajout recette ${data.nom_court}`,
          content: btoa(unescape(encodeURIComponent(yamlContent))),
          branch: branchName
        })
      }
    );
    const fileData = await safeJson(fileResp);
    if (!fileResp.ok) throw new Error(fileData?.message || "Impossible de créer le fichier.");

    // 4️⃣ Create PR
    const prResp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          title: `Ajout recette ${data.nom_court}`,
          head: branchName,
          base: base
        })
      }
    );

    const prData = await safeJson(prResp);
    if (!prResp.ok) throw new Error(prData?.message || "Impossible de créer la PR.");

    if (prData && prData.html_url) {
      showSuccess(prData.html_url);
      resetForm(form);
    } else {
      throw new Error("PR créée, mais URL introuvable.");
    }
  } catch (err) {
    showError(err?.message || "Une erreur est survenue.");
  } finally {
    setSubmitLoading(form, false);
  }
}

function collectData(schema, container, path=[]) {
  if (schema.type === "object") {
    const obj = {};
    Object.entries(schema.properties).forEach(([key, prop]) => {
      obj[key] = collectData(prop, container, [...path, key]);
    });
    return obj;
  }

  if (schema.type === "array") {
    const items = [];
    container.querySelectorAll(`[data-path^="${path.join(".")}"]`).forEach(el => {
      if (el.value) items.push(el.value);
    });
    return items;
  }

  const selector = `[data-path="${path.join(".")}"]`;
  const input = container.querySelector(selector);

  if (!input) return null;

  if (schema.type === "boolean") return input.checked;
  if (schema.type === "integer") return parseInt(input.value) || null;
  if (schema.type === "number") return parseFloat(input.value) || null;

  return input.value || null;
}

// ---------------------------
//  URL import tab (repro)
// ---------------------------
function showUrlSuccess(prUrl) {
  const form = document.getElementById("url-form");
  const success = document.getElementById("url-success-message");
  const error = document.getElementById("url-error-message");
  const link = document.getElementById("url-pr-link");

  if (form) form.style.display = "none";

  error.classList.add("d-none");
  document.getElementById("url-error-text").textContent = "";

  success.classList.remove("d-none");
  link.href = prUrl;
  link.textContent = prUrl;

  window.scrollTo(0, 0);
}

function showUrlError(message) {
  const success = document.getElementById("url-success-message");
  const error = document.getElementById("url-error-message");

  success.classList.add("d-none");

  error.classList.remove("d-none");
  document.getElementById("url-error-text").textContent = message;

  window.scrollTo(0, 0);

  setTimeout(() => {
    error.classList.add("d-none");
  }, 10000);
}

function setUrlSubmitLoading(form, isLoading) {
  const btn = form.querySelector('button[type="submit"]');
  if (!btn) return;

  if (isLoading) {
    btn.disabled = true;
    btn.dataset.originalText = btn.dataset.originalText || btn.textContent;
    btn.innerHTML = `
      <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
      Soumission de l'URL...
    `;
    form.setAttribute("aria-busy", "true");
  } else {
    btn.disabled = false;
    btn.innerHTML = btn.dataset.originalText || "Soumettre l'URL";
    form.removeAttribute("aria-busy");
  }
}

async function handleUrlSubmit(e) {
  e.preventDefault();

  const form = e.target;
  if (!form.checkValidity()) {
    e.stopPropagation();
    form.classList.add("was-validated");
    return;
  }

  setUrlSubmitLoading(form, true);

  try {
    const url = document.getElementById("recipe-url").value;
    const submittedBy = document.getElementById("url-submitted-by").value;

    const pendingContent = {
      url: url,
      submitted_at: new Date().toISOString(),
      status: "pending"
    };

    if (submittedBy && submittedBy.trim()) {
      pendingContent.submitted_by = submittedBy.trim();
    }

    const filename = `pending-${Date.now()}.yaml`;

    const prUrl = await createUrlPullRequest(pendingContent, filename, url);
    showUrlSuccess(prUrl);
  } catch (err) {
    showUrlError(err?.message || "Une erreur est survenue.");
  } finally {
    setUrlSubmitLoading(form, false);
  }
}

async function createUrlPullRequest(pendingContent, filename, url) {
  const token = window.GITHUB_PAT;
  const owner = "alpa12";
  const repo = "recettes";
  const base = "dev";

  if (!token || !owner || !repo) {
    throw new Error("Configuration GitHub manquante.");
  }

  const headers = {
    "Authorization": "token " + token,
    "Accept": "application/vnd.github+json"
  };

  const yamlContent = jsyaml.dump(pendingContent, {
    indent: 2,
    lineWidth: -1,
    noRefs: true
  });

  const filepath = `recettes/pending/${filename}`;

  // 1️⃣ Get dev branch SHA
  const refResp = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/git/ref/heads/${base}`,
    { headers }
  );
  const refData = await safeJson(refResp);
  if (!refResp.ok) throw new Error(refData?.message || `Impossible de récupérer la branche ${base}.`);
  const baseSha = refData.object.sha;

  // 2️⃣ Create branch (suffix if exists)
  const baseBranchName = `recipe-url/${Date.now()}`;
  const branchName = await createBranchWithSuffixes({
    owner, repo, headers, baseSha, baseBranchName, maxAttempts: 20
  });

  // 3️⃣ Create the pending file
  const createFileResponse = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/contents/${filepath}`,
    {
      method: "PUT",
      headers,
      body: JSON.stringify({
        message: `Import de recette depuis URL: ${url}`,
        content: btoa(unescape(encodeURIComponent(yamlContent))),
        branch: branchName
      })
    }
  );

  const fileData = await safeJson(createFileResponse);
  if (!createFileResponse.ok) {
    throw new Error(fileData?.message || "Impossible de créer le fichier pending.");
  }

  // 4️⃣ Create PR (body identical to old version)
  const prBody =
`## Import de recette depuis URL

**URL:** ${url}
${pendingContent.submitted_by ? `**Soumis par:** ${pendingContent.submitted_by}
` : ""}
Cette recette nécessite un import automatique via LLM.

---

⚠️ Cette PR sera traitée automatiquement par le workflow d'import.`;

  const prResponse = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/pulls`,
    {
      method: "POST",
      headers,
      body: JSON.stringify({
        title: `Import recette: ${url}`,
        body: prBody,
        head: branchName,
        base: base
      })
    }
  );

  const prData = await safeJson(prResponse);
  if (!prResponse.ok) {
    throw new Error(prData?.message || "Impossible de créer la pull request.");
  }

  if (prData && prData.html_url) return prData.html_url;
  throw new Error("PR créée, mais URL introuvable.");
}
</script>
