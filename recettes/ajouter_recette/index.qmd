---
title: Ajouter une recette
image: index.jpg
order: 4
---

```{r}
#| echo: false
#| results: asis
#| message: false
#| warning: false
library(yaml)
library(jsonlite)

template <- yaml::read_yaml("../template.yaml")
schema <- template$`_schema`
token <- Sys.getenv("GITHUB_PAT")
mot_de_passe <- Sys.getenv("MOT_DE_PASSE")

# Inject variables for the client-side app
cat(paste0(
"<script>\n",
"window.RECIPE_SCHEMA = ", jsonlite::toJSON(schema, auto_unbox = TRUE), ";\n",
"window.GITHUB_PAT = ",  jsonlite::toJSON(token, auto_unbox = TRUE), ";\n",
"window.RECIPE_PASSWORD = ", jsonlite::toJSON(mot_de_passe, auto_unbox = TRUE), ";\n",
"</script>\n"
))
```

::: {.panel-tabset}

## Formulaire manuel

<div id="edit-banner" class="alert alert-info d-none" role="alert"></div>


```{=html}
<div class="card mb-3">
  <div class="card-body">
    <label for="site-password-manual" class="form-label required-field">Mot de passe</label>
    <input type="password" class="form-control" id="site-password-manual" placeholder="Entrez le mot de passe du site" autocomplete="off" required>
    <div class="form-text">Le bouton <strong>Soumettre</strong> sera activé seulement si le mot de passe correspond.</div>
    <div id="pw-feedback-manual" class="qrf-inline-warning d-none">Mot de passe incorrect.</div>
  </div>
</div>
```


<div id="recipe-form-container"></div>

<div id="success-message" class="alert alert-success d-none"></div>
<div id="error-message" class="alert alert-danger d-none"></div>

## Importer depuis une URL

```{=html}
<form id="url-form" class="mb-4 needs-validation" novalidate>
  <div class="mb-3">
    <label for="recipe-url" class="form-label required-field">URL de la recette</label>
    <input type="url" class="form-control" id="recipe-url" placeholder="https://exemple.com/ma-recette" required>
    <div class="invalid-feedback">Veuillez entrer une URL valide.</div>
  </div>

  <div class="mb-3">
    <label for="url-submitted-by" class="form-label">Votre nom (optionnel)</label>
    <input type="text" class="form-control" id="url-submitted-by" placeholder="Votre nom">
  </div>


  <div class="mb-3">
    <label for="site-password-url" class="form-label required-field">Mot de passe</label>
    <input type="password" class="form-control" id="site-password-url" placeholder="Entrez le mot de passe du site" autocomplete="off" required>
    <div class="form-text">Le bouton <strong>Soumettre l'URL</strong> sera activé seulement si le mot de passe correspond.</div>
    <div id="pw-feedback-url" class="invalid-feedback">Mot de passe incorrect.</div>
  </div>

  <div class="d-grid gap-2">
    <button type="submit" class="btn btn-primary btn-lg" id="url-submit-btn" disabled>Soumettre l'URL</button>
  </div>
</form>

<div id="url-success-message" class="alert alert-success d-none" role="alert">
  <h4 class="alert-heading">✅ Recette soumise avec succès!</h4>
  <p>Une demande d'ajout de recette a été créée avec votre URL.</p>
  <p class="mb-0">Vous pouvez la voir ici: <a id="url-pr-link" href="#" target="_blank" class="alert-link" rel="noopener noreferrer"></a></p>
</div>

<div id="url-error-message" class="alert alert-danger d-none" role="alert">
  <h4 class="alert-heading">❌ Erreur</h4>
  <p id="url-error-text"></p>
</div>
```

:::


```{=html}
<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
```


<style>
.required-field::after { content: " *"; color: var(--bs-danger); }

/* Inline warning under inputs (e.g., non-numeric YAML values) */
.qrf-inline-warning { margin-top: .25rem; font-size: .875rem; color: var(--bs-danger); }

/* Array items */
.qrf-array-item { border: 1px solid rgba(0,0,0,.10); border-radius: .5rem; padding: .75rem; margin-top: .5rem; background: rgba(0,0,0,.01); }
.qrf-array-item-header { display:flex; align-items:center; justify-content:space-between; gap:.75rem; margin-bottom: .5rem; }
.qrf-array-item-title { font-weight: 600; }

/* Compact row for primitive array items: input + remove on one line */
.qrf-inline-row { display:flex; align-items:flex-start; gap:.5rem; }
.qrf-inline-row .form-control,
.qrf-inline-row .form-select,
.qrf-inline-row textarea { flex: 1 1 auto; min-width: 0; }
.qrf-inline-row .btn { flex: 0 0 auto; white-space: nowrap; }

/* Three-up rows (temps, ingredients) */
.qrf-row-3 { display:flex; flex-wrap: wrap; gap: .75rem; }
.qrf-row-3 .qrf-col { flex: 1 1 200px; min-width: 200px; }

/* Comment row: meta (stars/name/date) on one line */
.qrf-row-comment-meta { display:flex; flex-wrap: wrap; gap: .75rem; align-items:flex-end; }
.qrf-row-comment-meta .qrf-col { flex: 1 1 200px; min-width: 200px; }
.qrf-row-comment-meta .qrf-col.small { flex: 0 0 220px; }
.qrf-row-comment-meta .qrf-col.tiny { flex: 0 0 180px; }

/* Slightly smaller labels inside dense rows */
.qrf-dense .form-label { margin-bottom: .25rem; font-size: .9rem; }

/* Star rating widget */
.qrf-stars { display:inline-flex; gap:.25rem; line-height:1; user-select:none; }
.qrf-star-btn { border:none; background:transparent; padding:0; font-size:1.25rem; cursor:pointer; }
.qrf-star-btn:focus { outline: 2px solid rgba(13,110,253,.35); outline-offset: 2px; border-radius: .25rem; }
.qrf-stars-muted { color: rgba(0,0,0,.25); }
.qrf-stars-active { color: #f0ad4e; } /* bootstrap-ish amber */
.qrf-stars-clear { font-size:.85rem; margin-left:.5rem; }

</style>


```{=html}
<script>
/**
 * Add support for commentaires as array of objects:
 * - commentaire (string)   [textarea]
 * - evaluation (int 1-5)  [select]
 * - nom (string)
 * - date (date)
 *
 * Existing behavior preserved:
 * - Edit banner
 * - No "Item 0/1"
 * - Inline remove for primitive arrays
 * - Special layouts: temps + ingredients
 *
 * Numeric strictness for qte remains: must be a number (blocks submit if YAML had non-numeric).
 */

document.addEventListener("DOMContentLoaded", async () => {
  try {
    const schema = window.RECIPE_SCHEMA;
    if (!schema) throw new Error("RECIPE_SCHEMA manquant.");

    const yamlPath = getQueryParam("yaml");
    let data = {};

    if (yamlPath) {
      const resp = await fetch(yamlPath, { cache: "no-store" });
      if (!resp.ok) throw new Error("Impossible de charger le YAML.");
      const text = await resp.text();
      data = jsyaml.load(text) || {};
      window.__EDIT_MODE__ = { yamlPath, original: data };

      const banner = document.getElementById("edit-banner");
      if (banner) {
        const name = data?.nom || "cette recette";
        banner.classList.remove("d-none");
        banner.innerHTML = `✏️ <strong>Modification en cours</strong> : <span class="ms-1">${escapeHtml(name)}</span>`;
      }
    }

    const form = renderFromData(schema, data, document.getElementById("recipe-form-container"));
    setupPasswordGateForManualForm(form);
    setupPasswordGateForUrlForm();
    setupUrlImportForm();
  } catch (e) {
    showError(e?.message || "Erreur au chargement du formulaire.");
  }
});

// ---------------------------
//  Helpers
// ---------------------------
function getQueryParam(name) {
  return new URLSearchParams(window.location.search).get(name);
}

function stripLeadingSlash(p) {
  if (!p) return "";
  return p.startsWith("/") ? p.slice(1) : p;
}

function slugify(str) {
  return str
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

function escapeHtml(s) {
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

// ---------------------------
//  Image upload (cover)
//  - We store images in /images/<guid>.jpg in the repo
//  - YAML stores only image_guid
// ---------------------------
window.__PENDING_IMAGE__ = null; // { guid, base64 } or null

function newGuid() {
  if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
  // fallback (not perfect, but fine)
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c === "x" ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function fileToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = () => reject(new Error("Impossible de lire le fichier image."));
    reader.onload = () => {
      const result = reader.result || "";
      // result looks like "data:image/jpeg;base64,...."
      const parts = String(result).split(",");
      resolve(parts.length > 1 ? parts[1] : "");
    };
    reader.readAsDataURL(file);
  });
}

// --- Cover image compression (client-side, static-friendly) ---
window.compressJpegFile = async function compressJpegFile(file, {
  maxWidth = 1600,
  maxHeight = 1600,
  quality = 0.82,      // 0..1
  minQuality = 0.55,   // lower bound when shrinking to meet maxBytes
  maxBytes = 900_000,  // aim < 1MB
} = {}) {
  if (!file) throw new Error("Aucun fichier fourni.");
  if (!/^image\/jpe?g$/i.test(file.type)) {
    throw new Error("Format non supporté. Utilise un JPG/JPEG.");
  }

  // Decode image
  const bitmap = await createImageBitmap(file);

  // Compute resize ratio
  const ratio = Math.min(1, maxWidth / bitmap.width, maxHeight / bitmap.height);
  const outW = Math.max(1, Math.round(bitmap.width * ratio));
  const outH = Math.max(1, Math.round(bitmap.height * ratio));

  // Draw to canvas
  const canvas = document.createElement("canvas");
  canvas.width = outW;
  canvas.height = outH;
  const ctx = canvas.getContext("2d", { alpha: false });

  // Improve downscaling quality
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  ctx.drawImage(bitmap, 0, 0, outW, outH);

  // Helper: canvas -> blob
  const canvasToBlob = (q) => new Promise((resolve, reject) => {
    canvas.toBlob((b) => {
      if (!b) return reject(new Error("Échec de conversion de l'image (toBlob)."));
      resolve(b);
    }, "image/jpeg", q);
  });

  // Iteratively reduce quality if needed
  let q = quality;
  let blob = await canvasToBlob(q);

  // If still too big, reduce quality gradually
  while (blob.size > maxBytes && q > minQuality) {
    q = Math.max(minQuality, q - 0.07);
    blob = await canvasToBlob(q);
  }

  // As a last resort: if still too big, reduce dimensions (progressively)
  let shrinkPasses = 0;
  while (blob.size > maxBytes && shrinkPasses < 4) {
    shrinkPasses += 1;
    canvas.width = Math.round(canvas.width * 0.85);
    canvas.height = Math.round(canvas.height * 0.85);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
    q = Math.max(minQuality, q);
    blob = await canvasToBlob(q);
  }

  const base64 = await blobToBase64Raw(blob);

  return {
    blob,
    base64,                 // raw base64 (no data:image/... prefix)
    width: canvas.width,
    height: canvas.height,
    sizeBytes: blob.size,
    qualityUsed: q,
  };
}


// Blob -> raw base64 (no prefix)
function blobToBase64Raw(blob) {
  return new Promise((resolve, reject) => {
    const r = new FileReader();
    r.onerror = () => reject(new Error("Impossible de lire le blob."));
    r.onload = () => {
      const s = r.result; // data:...;base64,xxx
      const idx = s.indexOf("base64,");
      if (idx === -1) return reject(new Error("Conversion base64 invalide."));
      resolve(s.slice(idx + "base64,".length));
    };
    r.readAsDataURL(blob);
  });
}


// ---------------------------
//  Password gate (manual + URL)
// ---------------------------
function isPasswordValid(pw) {
  const expected = window.RECIPE_PASSWORD || "";
  return String(pw || "") !== "" && String(pw) === String(expected);
}

function setupPasswordGateForManualForm(form) {
  const pwInput = document.getElementById("site-password-manual");
  const fb = document.getElementById("pw-feedback-manual");
  const submitBtn = form?.querySelector('button[type="submit"]');
  if (!pwInput || !submitBtn) return;

  submitBtn.disabled = true;

  const refresh = () => {
    const ok = isPasswordValid(pwInput.value);
    submitBtn.disabled = !ok;

    if (!ok && pwInput.value !== "") {
      fb?.classList.remove("d-none");
    } else {
      fb?.classList.add("d-none");
    }
  };

  pwInput.addEventListener("input", refresh);
  refresh();
}

function setupPasswordGateForUrlForm() {
  const form = document.getElementById("url-form");
  const pwInput = document.getElementById("site-password-url");
  const submitBtn = document.getElementById("url-submit-btn") || form?.querySelector('button[type="submit"]');
  if (!form || !pwInput || !submitBtn) return;

  const refresh = () => {
    const ok = isPasswordValid(pwInput.value);
    submitBtn.disabled = !ok;

    if (!ok && pwInput.value !== "") {
      pwInput.classList.add("is-invalid");
    } else {
      pwInput.classList.remove("is-invalid");
    }
  };

  pwInput.addEventListener("input", refresh);
  refresh();

  form.addEventListener("submit", (e) => {
    if (!isPasswordValid(pwInput.value)) {
      e.preventDefault();
      e.stopPropagation();
      pwInput.classList.add("is-invalid");
    }
  }, true);
}

// ---------------------------
//  URL import (create PR with a small YAML request)
// ---------------------------
function showUrlSuccess(prUrl) {
  const box = document.getElementById("url-success-message");
  const errBox = document.getElementById("url-error-message");
  const link = document.getElementById("url-pr-link");
  if (errBox) errBox.classList.add("d-none");
  if (box) box.classList.remove("d-none");
  if (link) {
    link.href = prUrl;
    link.textContent = prUrl;
  }
}

function showUrlError(message) {
  const box = document.getElementById("url-success-message");
  const errBox = document.getElementById("url-error-message");
  const txt = document.getElementById("url-error-text");
  if (box) box.classList.add("d-none");
  if (errBox) errBox.classList.remove("d-none");
  if (txt) txt.textContent = message;
}

function setUrlSubmitLoading(isLoading) {
  const btn = document.getElementById("url-submit-btn");
  if (!btn) return;
  if (isLoading) {
    btn.disabled = true;
    btn.dataset.originalText = btn.dataset.originalText || btn.textContent;
    btn.innerHTML = `<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Création de la demande...`;
  } else {
    btn.innerHTML = btn.dataset.originalText || "Soumettre l'URL";
    // re-check password gate state
    const pw = document.getElementById("site-password-url")?.value || "";
    btn.disabled = !isPasswordValid(pw);
  }
}

function urlSafeSlug(u) {
  try {
    const url = new URL(u);
    const host = url.hostname.replace(/^www\./, "");
    const path = url.pathname.replace(/\/+$/, "");
    const base = (host + (path ? "-" + path.split("/").filter(Boolean).slice(-2).join("-") : "")).slice(0, 80);
    return slugify(base || "recette-url");
  } catch {
    return slugify(u || "recette-url");
  }
}

function setupUrlImportForm() {
  const form = document.getElementById("url-form");
  if (!form) return;

  // Prevent default navigation (Quarto tabset would reset otherwise)
  form.addEventListener("submit", handleUrlSubmit);
}

async function handleUrlSubmit(e) {
  e.preventDefault();
  e.stopPropagation();

  const form = e.target;
  // Clear messages
  document.getElementById("url-success-message")?.classList.add("d-none");
  document.getElementById("url-error-message")?.classList.add("d-none");

  // Validate HTML5
  if (!form.checkValidity()) {
    form.classList.add("was-validated");
    return;
  }

  // Password gate (double check)
  const pw = document.getElementById("site-password-url")?.value || "";
  if (!isPasswordValid(pw)) {
    showUrlError("Mot de passe incorrect.");
    return;
  }

  const url = document.getElementById("recipe-url")?.value?.trim() || "";
  const submittedBy = document.getElementById("url-submitted-by")?.value?.trim() || null;

  setUrlSubmitLoading(true);

  try {
    const token = window.GITHUB_PAT;
    const owner = "alpa12";
    const repo = "recettes";
    const base = "dev";

    const headers = {
      "Authorization": "token " + token,
      "Accept": "application/vnd.github+json"
    };

    const refResp = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/ref/heads/${base}`, { headers });
    const refData = await safeJson(refResp);
    if (!refResp.ok) throw new Error(refData?.message || "Impossible de lire la branche de base.");
    const baseSha = refData.object.sha;

    const slug = urlSafeSlug(url);
    const guid = newGuid();

    // Store requests in a dedicated folder to avoid clashing with real recipes
    const filePath = `recettes/url_imports/${slug}-${guid}.yaml`;
    const baseBranchName = `recette-url/${slug}`;

    const branchName = await createBranchWithSuffixes({ owner, repo, headers, baseSha, baseBranchName });

    // 1) Upload cover image to the SAME branch before writing YAML/creating PR.
    // If upload fails, we stop here and DO NOT create the PR.
    await uploadPendingCoverImage({ owner, repo, headers, branchName });


    const payload = {
      url: url,
      submitted_by: submittedBy,
      submitted_at: new Date().toISOString().slice(0, 10)
    };

    const yamlContent = jsyaml.dump(payload, { indent: 2, lineWidth: -1 });

    const putBody = {
      message: `Demande ajout via URL (${slug})`,
      content: btoa(unescape(encodeURIComponent(yamlContent))),
      branch: branchName
    };

    const fileResp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`,
      { method: "PUT", headers, body: JSON.stringify(putBody) }
    );
    const fileData = await safeJson(fileResp);
    if (!fileResp.ok) throw new Error(fileData?.message || "Impossible d'écrire la demande URL.");

    const prResp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          title: `Ajout recette via URL: ${slug}`,
          head: branchName,
          base: base,
          body: `URL soumise: ${url}` + (submittedBy ? `\nSoumis par: ${submittedBy}` : "")
        })
      }
    );
    const prData = await safeJson(prResp);
    if (!prResp.ok) throw new Error(prData?.message || "Impossible de créer la PR.");

    if (prData?.html_url) {
      showUrlSuccess(prData.html_url);
      form.reset();
      form.classList.remove("was-validated");
    } else {
      throw new Error("PR créée, mais URL introuvable.");
    }
  } catch (err) {
    showUrlError(err?.message || "Une erreur est survenue.");
  } finally {
    setUrlSubmitLoading(false);
  }
}



// ---------------------------
//  UI messages
// ---------------------------
function showSuccess(prUrl) {
  const success = document.getElementById("success-message");
  const error = document.getElementById("error-message");

  error.classList.add("d-none");
  error.innerHTML = "";

  success.classList.remove("d-none");
  success.innerHTML = `
    <div><strong>Demande créée avec succès !</strong></div>
    <div><a href="${prUrl}" target="_blank" rel="noopener noreferrer">${prUrl}</a></div>
  `;
}

function showError(message) {
  const success = document.getElementById("success-message");
  const error = document.getElementById("error-message");

  success.classList.add("d-none");
  success.innerHTML = "";

  error.classList.remove("d-none");
  error.innerHTML = `<strong>Erreur :</strong> ${message}`;
}

function clearMessages() {
  const success = document.getElementById("success-message");
  const error = document.getElementById("error-message");
  success.classList.add("d-none");
  success.innerHTML = "";
  error.classList.add("d-none");
  error.innerHTML = "";
}

function resetForm(form) {
  form.reset();
  form.classList.remove("was-validated");
  form.querySelectorAll("[data-array-list]").forEach((list) => (list.innerHTML = ""));

  // Clear pending cover image state + previews
  window.__PENDING_IMAGE__ = null;
  form.querySelectorAll("img.qrf-cover-preview").forEach((img) => {
    img.style.display = "none";
    img.removeAttribute("src");
  });
}

function setSubmitLoading(form, isLoading, label="Soumettre la recette") {
  const btn = form.querySelector('button[type="submit"]');
  if (!btn) return;

  if (isLoading) {
    btn.disabled = true;
    btn.dataset.originalText = btn.dataset.originalText || btn.textContent;
    btn.innerHTML = `
      <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
      Création de la demande...
    `;
    form.setAttribute("aria-busy", "true");
  } else {
    btn.disabled = false;
    btn.innerHTML = btn.dataset.originalText || label;
    form.removeAttribute("aria-busy");
  }
}


function isQtePath(path) {
  return String(path[path.length - 1] || "") === "qte";
}

function normalizeNumericString(s) {
  // Accept both "0.5" and "0,5"
  return String(s ?? "").trim().replace(",", ".");
}

// ---------------------------
//  Renderer (schema -> DOM) : renderFromData
// ---------------------------
function renderFromData(schema, data, container) {
  container.innerHTML = "";

  const form = document.createElement("form");
  form.id = "recipe-form";
  form.classList.add("needs-validation");
  form.noValidate = true;

  form.appendChild(renderNode(schema, data, [], form));

  const btn = document.createElement("button");
  btn.type = "submit";
  btn.className = "btn btn-primary mt-3";
  btn.textContent = "Soumettre la recette";
  form.appendChild(btn);

  form.addEventListener("submit", handleSubmit);
  container.appendChild(form);
  return form;
}

function renderNode(schema, value, path, formRoot) {
  if (!schema) return document.createElement("div");
  if (schema.type === "object") return renderObject(schema, value, path, formRoot);
  if (schema.type === "array") return renderArray(schema, value, path, formRoot);
  return renderPrimitive(schema, value, path);
}

function isIngredientObjectSchema(schema) {
  if (!schema || schema.type !== "object") return false;
  const props = schema.properties || {};
  return Object.prototype.hasOwnProperty.call(props, "nom")
    && Object.prototype.hasOwnProperty.call(props, "qte")
    && Object.prototype.hasOwnProperty.call(props, "uni");
}

function isCommentObjectSchema(schema) {
  if (!schema || schema.type !== "object") return false;
  const props = schema.properties || {};
  return Object.prototype.hasOwnProperty.call(props, "commentaire")
    && Object.prototype.hasOwnProperty.call(props, "evaluation")
    && Object.prototype.hasOwnProperty.call(props, "nom")
    && Object.prototype.hasOwnProperty.call(props, "date");
}

function isTempsObjectPath(path, schema) {
  const last = path[path.length - 1];
  return last === "temps" || schema?.title === "Temps";
}

function renderObject(schema, value, path, formRoot) {
  if (isIngredientObjectSchema(schema)) {
    return renderIngredientRow(schema, value, path);
  }
  if (isCommentObjectSchema(schema)) {
    return renderCommentRow(schema, value, path);
  }
  if (isTempsObjectPath(path, schema)) {
    return renderTempsRow(schema, value, path);
  }

  const wrapper = document.createElement("div");
  const props = schema.properties || {};
  const obj = (value && typeof value === "object" && !Array.isArray(value)) ? value : {};

  Object.entries(props).forEach(([key, prop]) => {
    const fieldPath = [...path, key];
    if (prop.type === "object") {
      wrapper.appendChild(renderSection(prop, key, obj[key], fieldPath, formRoot));
    } else {
      wrapper.appendChild(renderNode(prop, obj[key], fieldPath, formRoot));
    }
  });

  return wrapper;
}

function renderTempsRow(schema, value, path) {
  const obj = (value && typeof value === "object" && !Array.isArray(value)) ? value : {};
  const props = schema.properties || {};

  const wrap = document.createElement("div");
  wrap.className = "qrf-row-3 qrf-dense";

  ["preparation","cuisson","refrigeration"].forEach((k) => {
    if (!props[k]) return;
    const col = document.createElement("div");
    col.className = "qrf-col";
    col.appendChild(renderPrimitive(props[k], obj[k], [...path, k], true));
    wrap.appendChild(col);
  });

  return wrap;
}

function renderIngredientRow(schema, value, path) {
  const obj = (value && typeof value === "object" && !Array.isArray(value)) ? value : {};
  const props = schema.properties || {};

  const wrap = document.createElement("div");
  wrap.className = "qrf-row-3 qrf-dense";

  ["nom","qte","uni"].forEach((k) => {
    const col = document.createElement("div");
    col.className = "qrf-col";
    col.appendChild(renderPrimitive(props[k], obj[k], [...path, k], true));
    wrap.appendChild(col);
  });

  return wrap;
}

function renderCommentRow(schema, value, path) {
  const obj = (value && typeof value === "object" && !Array.isArray(value)) ? value : {};
  const props = schema.properties || {};

  const wrapper = document.createElement("div");

  // Meta row: evaluation / nom / date
  const meta = document.createElement("div");
  meta.className = "qrf-row-comment-meta qrf-dense";

  const colEval = document.createElement("div");
  colEval.className = "qrf-col tiny";
  colEval.appendChild(renderPrimitive(props["evaluation"], obj["evaluation"], [...path, "evaluation"], true));
  meta.appendChild(colEval);

  const colNom = document.createElement("div");
  colNom.className = "qrf-col small";
  colNom.appendChild(renderPrimitive(props["nom"], obj["nom"], [...path, "nom"], true));
  meta.appendChild(colNom);

  const colDate = document.createElement("div");
  colDate.className = "qrf-col tiny";
  colDate.appendChild(renderPrimitive(props["date"], obj["date"], [...path, "date"], true));
  meta.appendChild(colDate);

  wrapper.appendChild(meta);

  // Comment text (full width)
  wrapper.appendChild(renderPrimitive(props["commentaire"], obj["commentaire"], [...path, "commentaire"], false));

  return wrapper;
}

function renderSection(schema, title, value, path, formRoot) {
  const div = document.createElement("div");
  div.className = "card mb-3";

  const body = document.createElement("div");
  body.className = "card-body";

  const h = document.createElement("h5");
  h.className = "card-title";
  h.textContent = schema.title || title;
  body.appendChild(h);

  body.appendChild(renderObject(schema, value, path, formRoot));
  div.appendChild(body);
  return div;
}

function labelForArrayItems(arrayPath, itemSchema) {
  const lastKey = arrayPath[arrayPath.length - 1];
  const map = {
    categories: "Catégorie",
    commentaires: "Commentaire",
    equipements: "Équipement",
    preparation: "Section",
    etapes: "Étape",
    ingredients: "Ingrédient"
  };
  if (map[lastKey]) return map[lastKey];
  if (itemSchema?.title) return itemSchema.title;
  return "Élément";
}

function renderArray(schema, value, path, formRoot) {
  const div = document.createElement("div");
  div.className = "mb-3";
  div.dataset.arrayPath = path.join(".");

  const label = document.createElement("label");
  label.className = "form-label fw-bold";
  label.textContent = schema.title || path[path.length - 1] || "Liste";
  div.appendChild(label);

  if (schema.description) {
    const help = document.createElement("div");
    help.className = "form-text";
    help.textContent = schema.description;
    div.appendChild(help);
  }

  const list = document.createElement("div");
  list.dataset.arrayList = "1";
  div.appendChild(list);

  const arr = Array.isArray(value) ? value : [];
  for (let i = 0; i < arr.length; i++) {
    addArrayItem(list, schema.items, path, arr[i], formRoot);
  }

  if (arr.length === 0 && schema.items?.type !== "object") {
    addArrayItem(list, schema.items, path, null, formRoot);
  }

  const addBtn = document.createElement("button");
  addBtn.type = "button";
  addBtn.className = "btn btn-outline-primary btn-sm mt-2";
  addBtn.textContent = "+ Ajouter";
  addBtn.onclick = () => addArrayItem(list, schema.items, path, null, formRoot);
  div.appendChild(addBtn);

  return div;
}

function addArrayItem(list, itemSchema, path, initialData, formRoot) {
  const idx = list.children.length;
  const itemPath = [...path, String(idx)];
  const itemDiv = renderArrayItem(itemSchema, itemPath, initialData, formRoot);
  list.appendChild(itemDiv);
}

function renderArrayItem(itemSchema, path, initialData, formRoot) {
  const itemDiv = document.createElement("div");
  itemDiv.className = "qrf-array-item";

  const idx = Number(path[path.length - 1] || 0) + 1;
  const friendly = labelForArrayItems(path.slice(0, -1), itemSchema);

  // Primitive arrays => inline input + remove
  if (itemSchema.type !== "object") {
    const row = document.createElement("div");
    row.className = "qrf-inline-row";

    const field = renderPrimitive(itemSchema, initialData, path, true);
    const input = field.querySelector("input, select, textarea");
    const label = field.querySelector("label");
    const warn = field.querySelector(".qrf-inline-warning");
    if (label) label.remove();

    const inputWrap = document.createElement("div");
    inputWrap.className = "flex-grow-1";
    if (input) inputWrap.appendChild(input);
    if (warn) inputWrap.appendChild(warn);

    const removeBtn = document.createElement("button");
    removeBtn.type = "button";
    removeBtn.className = "btn btn-sm btn-outline-danger";
    removeBtn.textContent = "Retirer";
    removeBtn.onclick = () => {
      itemDiv.remove();
      renumberArray(listFromItem(itemDiv), path.slice(0, -1).join("."));
    };

    row.appendChild(inputWrap);
    row.appendChild(removeBtn);
    itemDiv.appendChild(row);
    return itemDiv;
  }

  // Object array items => header + body
  const header = document.createElement("div");
  header.className = "qrf-array-item-header";

  const title = document.createElement("div");
  title.className = "qrf-array-item-title";
  title.textContent = `${friendly} ${idx}`;
  header.appendChild(title);

  const removeBtn = document.createElement("button");
  removeBtn.type = "button";
  removeBtn.className = "btn btn-sm btn-outline-danger";
  removeBtn.textContent = "Retirer";
  removeBtn.onclick = () => {
    itemDiv.remove();
    renumberArray(listFromItem(itemDiv), path.slice(0, -1).join("."));
  };
  header.appendChild(removeBtn);

  itemDiv.appendChild(header);
  itemDiv.appendChild(renderObject(itemSchema, initialData, path, formRoot));
  return itemDiv;
}

function listFromItem(itemDiv) { return itemDiv.parentElement; }

function renumberArray(listEl, arrayPath) {
  if (!listEl) return;
  const items = Array.from(listEl.children);
  items.forEach((itemDiv, i) => {
    const any = itemDiv.querySelector("[data-path], [data-array-path]");
    if (!any) return;

    const oldPrefixMatch = (any.getAttribute("data-path") || any.getAttribute("data-array-path") || "")
      .match(new RegExp("^" + escapeRegExp(arrayPath) + "\\.(\\d+)(\\.|$)"));
    if (!oldPrefixMatch) return;

    const oldIndex = oldPrefixMatch[1];
    const from = arrayPath + "." + oldIndex;
    const to = arrayPath + "." + String(i);

    itemDiv.querySelectorAll("[data-path]").forEach((n) => {
      const p = n.getAttribute("data-path");
      if (p && p.startsWith(from)) n.setAttribute("data-path", to + p.slice(from.length));
    });

    itemDiv.querySelectorAll("[data-array-path]").forEach((n) => {
      const p = n.getAttribute("data-array-path");
      if (p && p.startsWith(from)) n.setAttribute("data-array-path", to + p.slice(from.length));
    });

    const title = itemDiv.querySelector(".qrf-array-item-title");
    if (title) title.textContent = title.textContent.replace(/\d+$/, String(i + 1));
  });
}

function escapeRegExp(s){ return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

// ui helpers
function getUiWidget(schema) {
  const ui = schema && schema.ui;
  return ui && ui.widget ? String(ui.widget) : null;
}


function renderPrimitive(schema, value, path, dense=false) {
  const key = path[path.length - 1] || "";
  const div = document.createElement("div");
  div.className = dense ? "mb-0 qrf-dense" : "mb-3";

  const label = document.createElement("label");
  label.className = "form-label";
  label.textContent = schema.title || key;
  div.appendChild(label);

  // Special: image cover upload (image_guid)
  if (String(path[path.length - 1] || "") === "image_guid") {
    // Hidden input stores the guid in the YAML
    const hidden = document.createElement("input");
    hidden.type = "text";
    hidden.className = "form-control d-none";
    hidden.dataset.path = path.join(".");
    hidden.value = (value ?? "") === "" ? "" : String(value);

    const row = document.createElement("div");
    row.className = "d-flex flex-wrap gap-2 align-items-end";

    const left = document.createElement("div");
    left.className = "flex-grow-1";

    const file = document.createElement("input");
    file.type = "file";
    file.accept = "image/jpeg";
    file.className = "form-control";
    file.id = "cover-image-file";
    left.appendChild(file);

    const help = document.createElement("div");
    help.className = "form-text";
    help.textContent = "Formats acceptés : JPG seulement.";
    left.appendChild(help);

    const right = document.createElement("div");
    right.className = "d-flex gap-2";

    const preview = document.createElement("img");
    preview.id = "cover-image-preview";
    preview.style.maxHeight = "80px";
    preview.style.borderRadius = ".5rem";
    preview.style.display = "none";
    preview.alt = "Aperçu de l'image";
    right.appendChild(preview);

    const clearBtn = document.createElement("button");
    clearBtn.type = "button";
    clearBtn.className = "btn btn-outline-secondary";
    clearBtn.textContent = "Retirer l'image";
    clearBtn.onclick = () => {
      file.value = "";
      preview.style.display = "none";
      preview.removeAttribute("src");
      // If we are editing, keep existing guid unless user explicitly clears
      hidden.value = "";
      window.__PENDING_IMAGE__ = null;
    };
    right.appendChild(clearBtn);

    row.appendChild(left);
    row.appendChild(right);

    // If editing and a guid exists, show current image (best-effort)
    if (hidden.value) {
      preview.src = "/images/" + hidden.value + ".jpg";
      preview.style.display = "block";
    }

    file.addEventListener("change", async () => {
      const f = file.files && file.files[0] ? file.files[0] : null;
      if (!f) return;

      // Validate type + size early (GitHub Contents API is not meant for large binaries)
      const isJpeg = (f.type === "image/jpeg" || f.name.toLowerCase().endsWith(".jpg") || f.name.toLowerCase().endsWith(".jpeg"));
      if (!isJpeg) {
        file.value = "";
        window.__PENDING_IMAGE__ = null;
        hidden.value = "";
        preview.style.display = "none";
        preview.removeAttribute("src");
        alert("Merci de choisir un fichier JPG/JPEG.");
        return;
      }

      const MAX_BYTES = 900000; // target size after compression (~0.9MB)

      try {
        // Always compress/resize client-side to keep PRs light and to avoid Contents API issues.
        if (typeof window.compressJpegFile !== 'function') {
        throw new Error("compressJpegFile n'est pas chargé (script non exécuté ou scope). Vérifie l'ordre des <script>.");
      }
      const result = await window.compressJpegFile(f, {
          maxWidth: 1600,
          maxHeight: 1600,
          quality: 0.82,
          maxBytes: MAX_BYTES
        });

        const guid = newGuid();
        window.__PENDING_IMAGE__ = { guid, base64: result.base64 };
        hidden.value = guid;

        // preview compressed blob
        if (preview.dataset && preview.dataset.blobUrl) {
          try { URL.revokeObjectURL(preview.dataset.blobUrl); } catch (e) {}
        }
        const url = URL.createObjectURL(result.blob);
        if (preview.dataset) preview.dataset.blobUrl = url;
        preview.src = url;
        preview.style.display = "block";
      } catch (err) {
        file.value = "";
        window.__PENDING_IMAGE__ = null;
        hidden.value = "";
        preview.style.display = "none";
        preview.removeAttribute("src");
        alert(err && err.message ? err.message : "Échec de compression de l'image.");
        return;
      }
    });

    div.appendChild(row);
    div.appendChild(hidden);
    return div;
  }


  // Enum => widget (stars) for evaluation 1..5, otherwise select
  if (Array.isArray(schema.enum) && schema.enum.length > 0) {
    const isStars =
      schema.enum.length === 5 &&
      schema.enum.every((v, i) => Number(v) === i + 1) &&
      String(path[path.length - 1] || "") === "evaluation";

    if (isStars) {
      const hidden = document.createElement("input");
      hidden.type = "number";
      hidden.className = "form-control d-none";
      hidden.dataset.path = path.join(".");
      hidden.min = "1";
      hidden.max = "5";
      hidden.step = "1";
      hidden.value = (value ?? "") === "" ? "" : String(value);

      const wrap = document.createElement("div");
      wrap.className = "d-flex align-items-center gap-2";

      const stars = document.createElement("div");
      stars.className = "qrf-stars";
      stars.setAttribute("role", "radiogroup");

      function currentVal() {
        if (hidden.value === "") return null;
        const n = parseInt(hidden.value, 10);
        return Number.isFinite(n) ? n : null;
      }

      function renderStars() {
        const v = currentVal();
        stars.querySelectorAll("button").forEach((btn, i) => {
          const n = i + 1;
          btn.textContent = v !== null && n <= v ? "★" : "☆";
        });
      }

      for (let i = 1; i <= 5; i++) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "qrf-star-btn";
        b.textContent = "☆";
        b.onclick = () => {
          hidden.value = (currentVal() === i) ? "" : String(i);
          renderStars();
        };
        stars.appendChild(b);
      }

      const clear = document.createElement("button");
      clear.type = "button";
      clear.className = "btn btn-link p-0 qrf-stars-clear";
      clear.textContent = "Effacer";
      clear.onclick = () => { hidden.value = ""; renderStars(); };

      wrap.appendChild(stars);
      wrap.appendChild(clear);

      div.appendChild(wrap);
      div.appendChild(hidden);
      renderStars();
      return div;
    }

    const select = document.createElement("select");
    select.className = "form-select";
    select.dataset.path = path.join(".");

    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "—";
    select.appendChild(opt0);

    for (const v of schema.enum) {
      const opt = document.createElement("option");
      opt.value = String(v);
      opt.textContent = String(v);
      select.appendChild(opt);
    }

    if (value !== null && value !== undefined && value !== "") {
      select.value = String(value);
    }

    div.appendChild(select);
    return div;
  }

  let input = document.createElement("input");
  input.className = "form-control";
  input.dataset.path = path.join(".");

  // Boolean
  if (schema.type === "boolean") {
    input.type = "checkbox";
    input.className = "form-check-input ms-2";
    input.checked = !!value;
    div.appendChild(input);
    return div;
  }

  // Numeric
  if (schema.type === "integer" || schema.type === "number") {
    const isQte = String(path[path.length - 1] || "") === "qte";

    if (schema.type === "number" && isQte) {
      input.type = "text";
      input.inputMode = "decimal";
      input.placeholder = "Ex: 0.5 ou 0,5";
      input.pattern = "^\\s*\\d+(?:[\\.,]\\d+)?\\s*$";
      input.addEventListener("input", () => {
        if (input.value.includes(",")) input.value = input.value.replace(",", ".");
      });
    } else {
      input.type = "number";
      input.step = schema.type === "integer" ? "1" : "any";
    }

    if (typeof value === "number" && !Number.isNaN(value)) {
      input.value = String(value);
    } else if (value === null || value === undefined) {
      input.value = "";
    } else {
      input.value = "";
      input.dataset.nonNumericLoaded = "true";
      const warn = document.createElement("div");
      warn.className = "qrf-inline-warning";
      warn.textContent = "Valeur non numérique dans le YAML (corriger: ex. 0.5 au lieu de 1/2).";
      div.appendChild(warn);
    }

    div.appendChild(input);
    return div;
  }

  // Text / date
  if (schema.format === "date") {
    input.type = "date";
    input.value = value ?? "";
  } else {
    input.type = "text";
    input.value = value ?? "";
  }

  div.appendChild(input);
  return div;
}


// ---------------------------
//  Serialize (DOM -> data)
// ---------------------------
function serializeToData(schema, container, path=[]) {
  if (schema.type === "object") {
    const obj = {};
    Object.entries(schema.properties || {}).forEach(([key, prop]) => {
      obj[key] = serializeToData(prop, container, [...path, key]);
    });
    return obj;
  }

  if (schema.type === "array") {
    const arrWrap = container.querySelector(`[data-array-path="${path.join(".")}"]`);
    if (!arrWrap) return [];
    const list = arrWrap.querySelector(`[data-array-list]`);
    if (!list) return [];

    const out = [];
    Array.from(list.children).forEach((itemDiv, i) => {
      const itemPath = [...path, String(i)];
      const v = serializeToData(schema.items, itemDiv, itemPath);

      if (schema.items.type === "object") {
        // Drop empty objects (all fields null/empty)
        if (!isEmptyObject(v)) out.push(v);
      } else {
        if (v !== null && v !== "") out.push(v);
      }
    });
    return out;
  }

  const input = container.querySelector(`[data-path="${path.join(".")}"]`);
  if (!input) return null;

  if (schema.type === "boolean") return input.checked;

  // select
  if (input.tagName === "SELECT") {
    const v = input.value;
    if (v === "") return null;
    return schema.type === "integer" ? parseInt(normalizeNumericString(v), 10) : v;
  }

  if (schema.type === "integer") return input.value === "" ? null : parseInt(normalizeNumericString(input.value), 10);
  if (schema.type === "number")  return input.value === "" ? null : parseFloat(normalizeNumericString(input.value));
  return input.value === "" ? null : input.value;
}

function isEmptyObject(obj) {
  if (!obj || typeof obj !== "object") return true;
  return Object.values(obj).every(v => v === null || v === "" || v === undefined);
}

// ---------------------------
//  Numeric strictness guard (blocks submit)
// ---------------------------
function findNonNumericLoadedInputs(form) {
  return Array.from(form.querySelectorAll('input[type="number"]'))
    .filter(inp => inp.dataset && inp.dataset.nonNumericLoaded === "true");
}

// ---------------------------
//  GitHub helpers (unchanged)
// ---------------------------
async function safeJson(resp) {
  try { return await resp.json(); } catch { return null; }
}

async function getFileSha({ owner, repo, headers, filePath, branch }) {
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${encodeURIComponent(branch)}`;
  const resp = await fetch(url, { headers });
  const data = await safeJson(resp);
  if (resp.status === 404) return null;
  if (!resp.ok) throw new Error(data?.message || "Impossible de lire le fichier existant (SHA).");
  return data?.sha || null;
}

async function createBranchWithSuffixes({ owner, repo, headers, baseSha, baseBranchName, maxAttempts=20 }) {
  for (let i = 1; i <= maxAttempts; i++) {
    const branchName = (i === 1) ? baseBranchName : `${baseBranchName}-${i}`;
    const resp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/git/refs`,
      { method: "POST", headers, body: JSON.stringify({ ref: `refs/heads/${branchName}`, sha: baseSha }) }
    );
    const data = await safeJson(resp);
    if (resp.ok) return branchName;

    const msg = (data && data.message) ? data.message : "";
    const isAlreadyExists = resp.status === 422 && msg.toLowerCase().includes("reference already exists");
    if (isAlreadyExists) continue;

    throw new Error(msg || `Impossible de créer la branche (status ${resp.status}).`);
  }
  throw new Error("Impossible de créer une branche unique après plusieurs tentatives.");
}


// ---------------------------
//  GitHub: upload cover image (binary) to /images/<guid>.jpg
//  IMPORTANT: GitHub Contents API expects "content" = base64 of raw bytes.
//  Our fileToBase64() already returns that base64 (no data: prefix).
// ---------------------------
async function uploadPendingCoverImage({ owner, repo, headers, branchName }) {
  const pending = window.__PENDING_IMAGE__;
  if (!pending) return null;

  const guid = pending.guid;
  const base64Raw = pending.base64;

  if (!guid) throw new Error("Image: GUID manquant.");
  if (!base64Raw || typeof base64Raw !== "string") {
    throw new Error("Image: encodage base64 impossible (contenu vide).");
  }
  // sanity: reject accidental data URL prefix
  if (base64Raw.startsWith("data:")) {
    throw new Error("Image: encodage invalide (préfixe data: détecté).");
  }

  const filePath = `images/${guid}.jpg`;

  // If file already exists in this branch, GitHub requires sha to update
  const existingSha = await getFileSha({ owner, repo, headers, filePath, branch: branchName });

  const putBody = {
    message: `Ajout image couverture ${guid}`,
    content: base64Raw,
    branch: branchName
  };
  if (existingSha) putBody.sha = existingSha;

  const resp = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`,
    { method: "PUT", headers, body: JSON.stringify(putBody) }
  );
  const data = await safeJson(resp);
  if (!resp.ok) {
    const msg = data?.message || `Impossible d'uploader l'image (status ${resp.status}).`;
    throw new Error(msg);
  }

  // success: image is now committed in the branch
  return { guid, path: `/${filePath}` };
}
// ---------------------------
//  Submit handler (create or edit) — behavior preserved
// ---------------------------
async function handleSubmit(e) {
  e.preventDefault();
  clearMessages();

  const form = e.target;

  const bad = findNonNumericLoadedInputs(form);
  if (bad.length > 0) {
    form.classList.add("was-validated");
    showError("Cette recette contient au moins une quantité non numérique (ex: 1/2). Corrige le YAML en nombres (ex: 0.5), puis réessaie.");
    return;
  }

  if (!form.checkValidity()) {
    form.classList.add("was-validated");
    return;
  }

  setSubmitLoading(form, true);

  try {
    const data = serializeToData(window.RECIPE_SCHEMA, form, []);
    const yamlContent = jsyaml.dump(data, { indent: 2, lineWidth: -1 });

    const token = window.GITHUB_PAT;
    const owner = "alpa12";
    const repo = "recettes";
    const base = "dev";

    const headers = {
      "Authorization": "token " + token,
      "Accept": "application/vnd.github+json"
    };

    const refResp = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/ref/heads/${base}`, { headers });
    const refData = await safeJson(refResp);
    if (!refResp.ok) throw new Error(refData?.message || "Impossible de lire la branche de base.");
    const baseSha = refData.object.sha;

    const slug = slugify(data.nom_court || data.nom || "recette");

    const filePath = window.__EDIT_MODE__
      ? stripLeadingSlash(window.__EDIT_MODE__.yamlPath)
      : `recettes/${slug}.yaml`;

    const baseBranchName = window.__EDIT_MODE__
      ? `recette-modif/${slug}`
      : `recette/${slug}`;

    const branchName = await createBranchWithSuffixes({ owner, repo, headers, baseSha, baseBranchName });

    // Upload cover image (if selected) to the same branch before creating the PR.
    await uploadPendingCoverImage({ owner, repo, headers, branchName });

    const existingSha = await getFileSha({ owner, repo, headers, filePath, branch: branchName });

    const putBody = {
      message: window.__EDIT_MODE__ ? `Modification recette ${slug}` : `Ajout recette ${slug}`,
      content: btoa(unescape(encodeURIComponent(yamlContent))),
      branch: branchName
    };
    if (existingSha) putBody.sha = existingSha;

    const fileResp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`,
      { method: "PUT", headers, body: JSON.stringify(putBody) }
    );
    const fileData = await safeJson(fileResp);
    if (!fileResp.ok) throw new Error(fileData?.message || "Impossible d'écrire le fichier.");

    const prResp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          title: window.__EDIT_MODE__ ? `Modification recette ${slug}` : `Ajout recette ${slug}`,
          head: branchName,
          base: base
        })
      }
    );
    const prData = await safeJson(prResp);
    if (!prResp.ok) throw new Error(prData?.message || "Impossible de créer la PR.");

    if (prData && prData.html_url) {
      showSuccess(prData.html_url);
      resetForm(form);
    } else {
      throw new Error("PR créée, mais URL introuvable.");
    }
  } catch (err) {
    showError(err?.message || "Une erreur est survenue.");
  } finally {
    setSubmitLoading(form, false);
  }
}
</script>
```
