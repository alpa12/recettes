---
title: Ajouter une recette
image: index.jpg
order: 4
---

```{r}
#| echo: false
#| results: asis
#| message: false
#| warning: false
library(yaml)
library(jsonlite)

template <- yaml::read_yaml("../template.yaml")
schema <- template$`_schema`
token <- Sys.getenv("GITHUB_PAT")

cat(
  "<script>",
  "window.RECIPE_SCHEMA = ", jsonlite::toJSON(schema, auto_unbox = TRUE), ";",
  "window.GITHUB_PAT = ",  jsonlite::toJSON(token, auto_unbox = TRUE), ";",
  "</script>"
)
```

::: {.panel-tabset}

## Formulaire manuel

<div id="recipe-form-container"></div>

<div id="success-message" class="alert alert-success d-none"></div>
<div id="error-message" class="alert alert-danger d-none"></div>

## Importer depuis une URL

```{=html}
<form id="url-form" class="mb-4 needs-validation" novalidate>
  <div class="mb-3">
    <label for="recipe-url" class="form-label required-field">URL de la recette</label>
    <input type="url" class="form-control" id="recipe-url" placeholder="https://exemple.com/ma-recette" required>
    <div class="invalid-feedback">Veuillez entrer une URL valide.</div>
  </div>

  <div class="mb-3">
    <label for="url-submitted-by" class="form-label">Votre nom (optionnel)</label>
    <input type="text" class="form-control" id="url-submitted-by" placeholder="Votre nom">
  </div>

  <div class="d-grid gap-2">
    <button type="submit" class="btn btn-primary btn-lg">Soumettre l'URL</button>
  </div>
</form>

<div id="url-success-message" class="alert alert-success d-none" role="alert">
  <h4 class="alert-heading">✅ Recette soumise avec succès!</h4>
  <p>Une demande d'ajout de recette a été créée avec votre URL.</p>
  <p class="mb-0">Vous pouvez la voir ici: <a id="url-pr-link" href="#" target="_blank" class="alert-link" rel="noopener noreferrer"></a></p>
</div>

<div id="url-error-message" class="alert alert-danger d-none" role="alert">
  <h4 class="alert-heading">❌ Erreur</h4>
  <p id="url-error-text"></p>
</div>
```

:::

<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

<style>
.required-field::after {
  content: " *";
  color: var(--bs-danger);
}
</style>

<script>
/**
 * IMPORTANT
 * ----------
 * Ton code appelait renderForm(...) mais ces fonctions n'étaient plus présentes,
 * donc une erreur JS stoppait tout et le formulaire n'apparaissait pas.
 * Ci-dessous, on réintroduit le renderer du formulaire (renderForm/renderObject/...)
 * tout en gardant ta logique de soumission existante.
 */

window.__EDIT_MODE__ = null;

// On attend "load" (plus robuste avec panel-tabset) plutôt que DOMContentLoaded.
window.addEventListener("load", async () => {
  try {
    if (!window.RECIPE_SCHEMA) {
      throw new Error("RECIPE_SCHEMA est introuvable (injection R non exécutée).");
    }

    renderForm(window.RECIPE_SCHEMA, "recipe-form-container", []);
    await maybeLoadYamlForEdit();
  } catch (err) {
    const error = document.getElementById("error-message");
    if (error) {
      error.classList.remove("d-none");
      error.innerHTML = `<strong>Erreur :</strong> ${err?.message || err}`;
    }
    // Aide debug
    console.error(err);
  }
});

// ---------------------------
//  Form rendering (manuel)
// ---------------------------
function renderForm(schema, containerId, path) {
  const container = document.getElementById(containerId);
  if (!container) throw new Error(`Container #${containerId} introuvable.`);
  container.innerHTML = "";

  const form = document.createElement("form");
  form.classList.add("needs-validation");
  form.noValidate = true;

  form.appendChild(renderObject(schema, path));

  const btn = document.createElement("button");
  btn.type = "submit";
  btn.className = "btn btn-primary mt-3";
  btn.textContent = "Soumettre la recette";
  form.appendChild(btn);

  form.addEventListener("submit", handleSubmit);
  container.appendChild(form);
}

function renderObject(schema, path) {
  const wrapper = document.createElement("div");

  Object.entries(schema.properties || {}).forEach(([key, prop]) => {
    const fieldPath = [...path, key];

    if (prop.type === "object") {
      wrapper.appendChild(renderSection(prop, key, fieldPath));
    } else if (prop.type === "array") {
      wrapper.appendChild(renderArray(prop, key, fieldPath));
    } else {
      wrapper.appendChild(
        renderPrimitive(
          prop, key, fieldPath,
          Array.isArray(schema.required) ? schema.required.includes(key) : false
        )
      );
    }
  });

  return wrapper;
}

function renderSection(schema, title, path) {
  const div = document.createElement("div");
  div.className = "card mb-3";

  const body = document.createElement("div");
  body.className = "card-body";

  const h = document.createElement("h5");
  h.className = "card-title";
  h.textContent = schema.title || title;
  body.appendChild(h);

  body.appendChild(renderObject(schema, path));
  div.appendChild(body);
  return div;
}

function renderArray(schema, key, path) {
  const div = document.createElement("div");
  div.className = "mb-3";

  const label = document.createElement("label");
  label.className = "form-label fw-bold";
  label.textContent = schema.title || key;
  div.appendChild(label);

  const list = document.createElement("div");
  list.dataset.arrayPath = path.join(".");
  div.appendChild(list);

  const addBtn = document.createElement("button");
  addBtn.type = "button";
  addBtn.className = "btn btn-outline-primary btn-sm mt-2";
  addBtn.textContent = "+ Ajouter";
  addBtn.onclick = () => {
    list.appendChild(renderArrayItem(schema.items, path));
  };

  // Si tu veux au moins 1 item par défaut pour les arrays de primitives, décommente:
  // if (schema.items && schema.items.type !== "object") list.appendChild(renderArrayItem(schema.items, path));

  div.appendChild(addBtn);
  return div;
}

function renderArrayItem(itemSchema, path) {
  const itemDiv = document.createElement("div");
  itemDiv.className = "border rounded p-3 mt-2";

  if (itemSchema && itemSchema.type === "object") {
    itemDiv.appendChild(renderObject(itemSchema, path));
  } else {
    // Primitive item
    itemDiv.appendChild(renderPrimitive(itemSchema || {type:"string"}, "", path, false));
  }

  const removeBtn = document.createElement("button");
  removeBtn.type = "button";
  removeBtn.className = "btn btn-sm btn-outline-danger mt-2";
  removeBtn.textContent = "Retirer";
  removeBtn.onclick = () => itemDiv.remove();

  itemDiv.appendChild(removeBtn);
  return itemDiv;
}

function renderPrimitive(schema, key, path, required=false) {
  const div = document.createElement("div");
  div.className = "mb-3";

  const label = document.createElement("label");
  label.className = "form-label";
  label.textContent = (schema && schema.title) ? schema.title : (key || "");
  if (required) label.classList.add("required-field");
  div.appendChild(label);

  let input;

  if (schema && schema.type === "boolean") {
    input = document.createElement("input");
    input.type = "checkbox";
    input.className = "form-check-input ms-2";
  } else {
    input = document.createElement("input");
    input.type = (schema && (schema.type === "integer" || schema.type === "number")) ? "number" : "text";
    input.className = "form-control";
  }

  input.dataset.path = path.join(".");
  if (required) input.required = true;
  if (schema && schema.description) input.placeholder = schema.description;

  div.appendChild(input);
  return div;
}

// ---------------------------
//  Helpers
// ---------------------------
function slugify(str) {
  return str
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

function stripLeadingSlash(p) {
  if (!p) return "";
  return p.startsWith("/") ? p.slice(1) : p;
}

function getQueryParam(name) {
  return new URLSearchParams(window.location.search).get(name);
}

function showError(message) {
  const success = document.getElementById("success-message");
  const error = document.getElementById("error-message");

  if (success) {
    success.classList.add("d-none");
    success.innerHTML = "";
  }
  if (error) {
    error.classList.remove("d-none");
    error.innerHTML = `<strong>Erreur :</strong> ${message}`;
  }
}

// ---------------------------
//  (Optionnel) Edit mode : charge un YAML et pré-remplit
// ---------------------------
async function maybeLoadYamlForEdit() {
  const yamlParam = getQueryParam("yaml");
  if (!yamlParam) return;

  // Supporte:
  //  - chemins absolus: /recettes/accompagnements/xxx.yaml
  //  - chemins relatifs (par rapport à cette page): ../accompagnements/xxx.yaml
  //  - anciens liens sans slash initial: recettes/accompagnements/xxx.yaml
  const normalizedParam = yamlParam.startsWith("http")
    ? yamlParam
    : (yamlParam.startsWith("/") || yamlParam.startsWith("../") ? yamlParam : ("/" + yamlParam));

  const yamlUrl = new URL(normalizedParam, window.location.href).toString();

  const resp = await fetch(yamlUrl);
  if (!resp.ok) throw new Error("Impossible de charger le YAML.");
  const text = await resp.text();
  const data = jsyaml.load(text);

  // Chemin "repo" (pour GitHub Contents API) basé sur le pathname.
  // Ex: /recettes/accompagnements/salade.yaml -> recettes/accompagnements/salade.yaml
  const repoPath = stripLeadingSlash(new URL(normalizedParam, window.location.origin).pathname);

  window.__EDIT_MODE__ = {
    yamlParam: normalizedParam,
    yamlUrl,
    repoPath,
    original: data
  };

  fillFormFromData(data);
}

function fillFormFromData(data, container=document) {
  for (const [key, value] of Object.entries(data || {})) {
    const input = container.querySelector(`[data-path="${key}"]`);
    if (!input) continue;

    if (input.type === "checkbox") input.checked = !!value;
    else if (value !== null && value !== undefined) input.value = value;
  }
}

// ---------------------------
//  Submit (ta logique, inchangée)
// ---------------------------
async function handleSubmit(e) {
  e.preventDefault();
  const form = e.target;

  if (!form.checkValidity()) {
    form.classList.add("was-validated");
    return;
  }

  try {
    const data = collectData(window.RECIPE_SCHEMA, form);
    const yamlContent = jsyaml.dump(data, { indent: 2, lineWidth: -1 });

    const token = window.GITHUB_PAT || "";
    const owner = "alpa12";
    const repo = "recettes";
    const base = "dev";

    // Permet de tester localement sans token (juste affichage)
    if (!token) {
      console.warn("GITHUB_PAT est vide: soumission désactivée en local (affichage OK).");
      document.getElementById("success-message").classList.remove("d-none");
      document.getElementById("success-message").textContent =
        "✅ Formulaire affiché. (Soumission désactivée car GITHUB_PAT est vide en local.)";
      return;
    }

    const headers = {
      "Authorization": "token " + token,
      "Accept": "application/vnd.github+json"
    };

    const refResp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/git/ref/heads/${base}`,
      { headers }
    );
    const refData = await refResp.json();
    const baseSha = refData.object.sha;

    const slug = slugify(data.nom_court);

    const filePath = window.__EDIT_MODE__
      ? window.__EDIT_MODE__.repoPath
      : `recettes/${slug}.yaml`;

    const baseBranchName = window.__EDIT_MODE__
      ? `recette-modif/${slug}`
      : `recette/${slug}`;

    const branchName = await createBranchWithSuffixes({
      owner, repo, headers, baseSha, baseBranchName
    });

    await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`,
      {
        method: "PUT",
        headers,
        body: JSON.stringify({
          message: window.__EDIT_MODE__
            ? `Modification recette ${slug}`
            : `Ajout recette ${slug}`,
          content: btoa(unescape(encodeURIComponent(yamlContent))),
          branch: branchName
        })
      }
    );

    const prResp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          title: window.__EDIT_MODE__
            ? `Modification recette ${slug}`
            : `Ajout recette ${slug}`,
          head: branchName,
          base
        })
      }
    );

    const prData = await prResp.json();
    document.getElementById("success-message").classList.remove("d-none");
    document.getElementById("success-message").innerHTML =
      `<a href="${prData.html_url}" target="_blank" rel="noopener noreferrer">${prData.html_url}</a>`;
  } catch (err) {
    showError(err?.message || "Une erreur est survenue.");
    console.error(err);
  }
}

function collectData(schema, container, path=[]) {
  if (schema.type === "object") {
    const obj = {};
    for (const [key, prop] of Object.entries(schema.properties || {})) {
      obj[key] = collectData(prop, container, [...path, key]);
    }
    return obj;
  }

  if (schema.type === "array") {
    const items = [];
    container.querySelectorAll(`[data-path^="${path.join(".")}"]`).forEach(el => {
      if (el.type === "checkbox") {
        // on ignore (arrays de boolean non utilisés ici)
      } else if (el.value !== undefined && el.value !== null && String(el.value).trim() !== "") {
        items.push(el.value);
      }
    });
    return items;
  }

  const input = container.querySelector(`[data-path="${path.join(".")}"]`);
  if (!input) return null;
  if (schema.type === "boolean") return input.checked;
  if (schema.type === "integer") return parseInt(input.value) || null;
  if (schema.type === "number") return parseFloat(input.value) || null;
  return input.value || null;
}

async function createBranchWithSuffixes({ owner, repo, headers, baseSha, baseBranchName }) {
  for (let i = 1; i <= 20; i++) {
    const branchName = i === 1 ? baseBranchName : `${baseBranchName}-${i}`;
    const resp = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/git/refs`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          ref: `refs/heads/${branchName}`,
          sha: baseSha
        })
      }
    );
    if (resp.ok) return branchName;
    // Si la branche existe déjà, on retente avec suffixe
    const data = await safeJson(resp);
    const msg = (data && data.message) ? data.message : "";
    if (resp.status === 422 && msg.toLowerCase().includes("reference already exists")) continue;
  }
  throw new Error("Impossible de créer une branche unique.");
}

async function safeJson(resp) {
  try { return await resp.json(); } catch { return null; }
}
</script>
